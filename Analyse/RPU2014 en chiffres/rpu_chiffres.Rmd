---
title: "RPU 2014 en chiffres"
author: "JcB"
date: "31/12/2014"
output:
  html_document:
    toc: yes
---

init
----
Le fichier source s'appelle __dx__.

```{r init, echo=FALSE}
load("~/Documents/Resural/Stat Resural/RPU_2014/rpu2014d0112_provisoire.Rda")
library(lubridate)
library(knitr)

anc <- year(as.Date(dx$ENTREE[1])) # année courante

MOIS <- format(ISOdate(anc, 1:12, 1), "%B") # noms des mois
mois <- format(ISOdate(anc, 1:12, 1), "%b") # noms des mois abrégés

# pour que la semaine commence un lundi, il faut choisir 2007 comme année de référence
SEMAINE <- format(ISOdate(2007, 1, 1:7), "%A") # noms des jours de la semaine
semaine <- format(ISOdate(2007, 1, 1:7), "%a") # noms des jours de la semaine abrégés

```

Créer un calendrier
===================

Pb: on veut créer un vecteur de 365 ou 366 jours.

```{r}
date1 <- "2014-01-01"
date2 <- "2014-12-31"
calendrier <- seq(from = as.Date(date1), to = as.Date(date2), by = 1)

```

Compter les jours d'une semaine
===============================

Pb: on veut compter le nombre de lundi, merdi, ..., dimanche au cours d'une période de temps

```{r}
tapply(calendrier, wday(calendrier, label = TRUE), length)

```



Total RPU
=========
```{r total, echo=FALSE}
n <- nrow(dx)

```
Total RPU: `r n`

Nombre de RPU par mois
======================

Pb: on veut connaître le nombre de RPU par mois en 2014. Utilisé par le site internet. On utilise la fonction _tapply_ pour calculer la répartition mensuelle.

```{r}
# en valeur absolue
t <- tapply(as.Date(dx$ENTREE), month(as.Date(dx$ENTREE)), length)
names(t) <- format(ISOdate(2000, 1:12, 1), "%B")
t
# en pourcentage
round(prop.table(t)*100, 2)
# en différence. Rajoute 1 pour le mois de janvier
d <- c(1 ,diff(t))
names(d[1]) <- "janvier" # marche pas ?
barplot(d[1:11], col = ifelse(d > 0, "yellow", "green"), main = paste0("Variation du nombre de RPU en ", anc))

```

Nombre de RPU par semaine
=========================

Il y a deux méthodes possibles:

- __weekday__s du package _main_:
```{r}
wd <- tapply(as.Date(dx$ENTREE), weekdays(as.Date(dx$ENTREE)), length)
wd

```
- __wday__ du package _lubridate_. Inconvénient, la semaine commence le dimanche.
```{r}
# jours de semaine indicés par des entiers
wd <- tapply(as.Date(dx$ENTREE), wday(as.Date(dx$ENTREE)), length)
wd

# jours indicés par leur nom
wd <- tapply(as.Date(dx$ENTREE), wday(as.Date(dx$ENTREE), label = TRUE), length)
wd
```

Possibilité de correction:
```{r}
a <- c(wd[2:7],wd[1]) # on met le dimanche en dernier
names(a) <- SEMAINE
a

```

Demande ARS 2015 02
===================

Date: 2014-01-07

Dans le cadre de l'évaluation des CPOM des établissements, mais également en lien avec le travail qui s'initie en interne concernant la prise en charge de la personne âgée, nous souhaiterions pouvoir disposer des données par établissement concernant:
- le nombre de primo passages, et la proportion des patients de 75 ans et plus, en incluant les données de l'année 2014 (en précisant le niveau d'exhaustivité atteint dans la base 2014 à ce jour de la requête).
- la moyenne/médiane des temps de passages pour tout âge et pour les 75 ans et plus.
 
En y incluant les Diaconesses et la clinique Roosevelt, et des totaux par territoires de santé et pour la région.
 
Ci-joint un tableau pour clarifier la demande, avec certaines données déjà remplies à partir de la dernière version du rapport 2013.
 
Avez-vous d'ores et déjà des éléments d'explication (liés au codage notamment) au regard des temps de passage très hétérogènes d'une SU à l'autre?

Elements de réponse

nombre de primo passages
------------------------
`r n`

proportion de 75 ans et plus
----------------------------
```{r}
pop_75ans <- dx[dx$AGE > 74, "AGE"]
n_75ans <- length(pop_75ans)

summary(pop_75ans)
```
Exhaustivité pour l'âge: `r mean(!is.na(n_75ans)) * 100)` %

proportion des 75 ans: `r round(n_75ans * 100 / n, 2)` %.

Durée de passage chez les plus de 75 ans
----------------------------------------
```{r}
dp <- dx[!is.na(dx$ENTREE) & !is.na(dx$SORTIE) & dx$AGE > 74, c("SORTIE", "ENTREE", "AGE", "FINESS")]
mean(!is.na(dp$SORTIE))
mean(!is.na(dp$ENTREE))
sum(is.na(dp$ENTREE))
sum(is.na(dp$SORTIE))
dp <- dp[!is.na(dp$SORTIE) & !is.na(dp$ENTREE),]
```
Exhaustivité de 99%. Seuls 4 passages ne sont pas renseignés.

```{r presence}
# vecteur des heures d'entrées
s <- ymd_hms(dp$SORTIE)
# vecteurs des heures de sortie
e <- ymd_hms(dp$ENTREE)
# durée de présence en secondes
p <- s - e
length(p)
summary(as.numeric(p))
# résumé en minutes
summary(as.numeric(p)/60)

# vecteur des durée de présence en mn
p_mn <- as.numeric(p)/60
H48 <- 60 * 48
# durée de présence comprises entre 0 et 48 heures
p48 <- p_mn[p_mn < H48 + 1]
summary(p48)
length(p48)
# histogramme par tranche d'une heure
hist(p48, breaks = seq(0, 60*48, 60), main = "Durée de passage (par tranche d'une heure) \ndes patients de 75 ans et plus", xlab = "temps en minutes de 0 à 2880 minutes (48 heures)", ylab = "fréquence")

```
La durée de passage est bornée à 48 heures (recommandation FEDORU).

```{r}

```

