Fichier RPU quotdien
========================================================

Depuis février 2014, Alsace e-sante transmet quotidiennement un fichier contenant les RPU des 7 derniers jours (j-7 à j-1). Les données correspondant à J-7 sont considérées comme consolidées. Elles peuvent être extraites et stockées. Les données sont transmises de manière habituelle, c'est à dire un fichier .sql qu'il faut transcoder en R pour le nettoyer avant stockage.

__Au mois de mai 2014 la clinique des 3 frontières (C3F) a changé de N°FINESS__. (voir le paragraphe C3F)

#### Méthode rapide: voir __En Preatique__

Descriptif
----------

1. Le fichier des données est récupéré sur le serveur de test des HUS. Il st déposé dans le dossier de stockage (**/home/jcb/Documents/Resural/Stat Resural/Archives_Sagec/dataQ**) et dézippé.

2. le nom du fichier est construit de la manière suivante:
  - date.jour <- "2014-02-21"
  - file <- paste0("rpu_", date.jour, "_dump.sql")
  - *date.jour est du type AAAA-MM-JJ*

2. le fichier est ensuite transféré dans la base de données **archives** dans la table **RPU__** via R
  - il est important que le répertoire de travail temporaire soit positionné dans le dossier *dataQ*
```{}
    wd <- getwd()
    setwd("~/Documents/Resural/Stat Resural/Archives_Sagec/dataQ")
    system(paste0("mysql -u root -pmarion archives < ", file))
    setwd(wd)
```

3. Lecture des données dans R
```{}
  library("RMySQL")
  con<-dbConnect(MySQL(),group = "archives")
  rs<-dbSendQuery(con,paste("SELECT * FROM RPU__ ",sep=""))
  dx<-fetch(rs,n=-1,encoding = "UTF-8")
  max(dx$ENTREE)
  min(dx$ENTREE)
```

4. nettoyage des données
  - suppression de la colonne 16: dx<-dx[,-16]
  - transcodage des FINESS (vérification nombre hôpitaux)
  - transformation en facteurs
  - création  d'une colonne AGE (alertes age < 0 et age > 120)
  
5. sauvegarde des données
  - jour à sauvegarder: jour <- as.Date(min(dx$ENTREE))
  - dday <- dx[as.Date(dx$ENTREE) == jour,]
  - fichier du jour: write.table(dday, paste0(date.jour,".csv"), sep=',', quote=TRUE, na="NA", row.names=FALSE,col.names=TRUE)
  - fichier général: write.table(dday, "RPU2014.csv", sep=',', quote=TRUE, na="NA", append = TRUE, row.names=FALSE,col.names=TRUE)

6. fonctions helpers

source("quot_utils.R") ou source("Preparation/RPU Quotidiens/quot_utils.R") en mode console.

- **rpu_jour**: fonction principale. En entrée on donne la date ISO souhaitée et en sortie retourne un dataframe avec les données correspondantes. Le WD doit pointer sur le dossier contenant le fichier .sql correspondant. Ce fichier doit être dézippé.
- **finess2hop**: transforme le code FINESS en nom court d'hopital
- **parse_rpu**: 

séquence:

- date.jour <- "2014_02"
- dx <- parse_rpu(date.jour)
- dx$FINESS <- as.factor(finess2hop(dx$FINESS))
- summary(dx$FINESS) fait un décompte des RPU par établissement sur la période => permet de vérifier si anomalies quantitatives. Suppose de disposer d'un historique moyenne, écart-type par type de jour.
- dx <- rpu2factor(dx)

```{}
#' Méthode générale
#' Préalable: disposer d'une base de donnée MySql avec une table appelée "archives". Cette base doit être référencée dans le fichier .my.conf
#'@ data date.jour nom du fichier. Pour une utilisation courante il s'agit de la date du jour au format ISO
parse_rpu <- function(date.jour){
  library("RMySQL")
  file <- paste0("rpu_", date.jour, "_dump.sql")
  wd <- getwd()
  setwd("~/Documents/Resural/Stat Resural/Archives_Sagec/dataQ")
  system(paste0("mysql -u root -pmarion archives < ", file))
  con<-dbConnect(MySQL(),group = "archives")
  rs<-dbSendQuery(con,paste("SELECT * FROM RPU__ ",sep=""))
  dx<-fetch(rs,n=-1,encoding = "UTF-8")
  dx<-dx[,-16]
  dx$FINESS <- as.factor(finess2hop(dx$FINESS))
  
  dx$AGE<-floor(as.numeric(as.Date(dx$ENTREE)-as.Date(dx$NAISSANCE))/365)
  
  dx$EXTRACT <- as.Date(dx$EXTRACT)
  setwd(wd)
}

#' Transformation du code Finess et nom court d'hôpital
finess2hop <- function(a){
  # a<-dx$FINESS
  a[a=="670000397"]<-"Sel"
  a[a=="680000684"]<-"Col"
  a[a=="670016237"]<-"Odi"
  a[a=="670000272"]<-"Wis"
  a[a=="680000700"]<-"Geb"
  a[a=="670780055"]<-"Hus"
  a[a=="680000197"]<-"3Fr"
  a[a=="680000627"]<-"Mul"
  a[a=="670000157"]<-"Hag"
  a[a=="680000320"]<-"Dia"
  a[a=="680000395"]<-"Alk"
  a[a=="670000165"]<-"Sav"
  a[a=="680000494"]<-"Ros"
  a[a=="670780162"]<-"Dts"
  a[a=="670780212"]<-"Ane"
  a[a=="680000601"]<-"Tan"
  return(a)
}
```

#### controles quotidiens
- nlevels(dx$FINESS) si différent de 14 => problème
- nb moyen et ecart-type de RPU par établissement et par jour

```{}
date1 <- "2014-03-01"
date2 <- "2014-03-05"
p <- seq(as.Date(date1), as.Date(date2), 1)
for(i in 1:length(p)){
  x <- parse_rpu(p[i])
  table(x$FINESS, as.Date(x$ENTREE))
}
```
Commentaires:
-------------
```{}
r <- table(as.Date(a$ENTREE), a$FINESS)
r <- r[,-13] # supprime la colonne 13 qui est totalement vide ?
r
```

- altkirch: toujours des trous inexpliqués: 1/1, 5/1, 11 et 12/1, 16/1, 18/1, 2/3
- mulhouse: 15/1, 7/2, 5-6-7/3 zéro rpu
- ste odile: 16 au 31/1 pas de rpu
- sélestat: 22 et 23/2 pas de RPU
- diaconat strasbourg: 1-2-3-4/3 puis plus rien
- roosvelt: depuis le 5/2 OK

En pratique
===========

- dézipper le fichier du jour dans */home/jcb/Documents/Resural/Stat Resural/Archives_Sagec/dataQ*
- charger le fichier **quot_utils.R** pour disposer des routines
- répéter l'étape **rj** autant de fois qu'il y a de fichiers à analyser
- assembler les fichiers avec **assemble()**

```{}
source("Preparation/RPU Quotidiens/quot_utils.R")
```

# si un seul fichier
```{}
rj <- rpu_jour("2014-03-20")
dx <- assemble(comment = TRUE)
```
Exhaustivité des RPU du jour:

table(as.Date(rj$ENTREE), rj$FINESS)

Si on a une collection de fichiers:
-----------------------------------

#### NB: SUPPRIMER LE FICHIER /home/jcb/Documents/Resural/Stat Resural/Archives_Sagec/dataQ/archivesCsv/rpu2014.data

```{}
date1 <- "2014-06-08"
date2 <- "2014-06-18"
p <- seq(as.Date(date1), as.Date(date2), 1)
for(i in 1:length(p)){
  dx <- rpu_jour(p[i])
}
dx <- assemble(comment = TRUE)

min(as.Date(dx$ENTREE))
max(as.Date(dx$ENTREE))
```

#### Sélectionner une période particulière (ie. mai 2014)
```{}
d05 <- dx[as.Date(dx$ENTREE) >= "2014-05-01" & as.Date(dx$ENTREE) < "2014-06-01",]
max(as.Date(d05$ENTREE))
min(as.Date(d05$ENTREE))
d05 <- normalise(d05)
save(d05, file="rpu2014d05.Rda")
load("rpu2014d0104.Rda")
rm(dx)
dx <- rbind(a, d05)
min(as.Date(dx$ENTREE))
max(as.Date(dx$ENTREE))
save(dx, file="rpu2014d0105.Rda")

table(as.Date(d05$ENTREE), d05$FINESS)
```


#### Eventuellement sauvegarder au format .Rda
```{}
dx <- normalise(dx)
dx <- dx[dx$ENTREE >= "2014-04-01" & dx$ENTREE < "2014-05-01",]
save(dx, file="rpu2014d04_provisoire.Rda")
```
et assembler le tout (d1 = fichier .Rda des mois précédents)
```{}
a <- rbind(d1,dx)
save(a, file="rpu2014d0103_provisoire.Rda")
```
Pour fabriquer les courbes interactives d'activité, voir le projet **dygraph**.

exhaustivité des données
------------------------
On forme une table en croisant FINESS et ENTREE:
```{}
table(as.Date(dx$ENTREE), dx$FINESS)
```
write.table(rpu, file="exaustivite_rpu.csv", sep=";", dec=",") enregistre la table au format .csv mais les colonnes sont décalées => rajouter un ";" en début de fichier.


#### Préparation des fichiers pour Dygraph 

  -> voir _Préparation des fichiers pour Dygraph.Rmd_
  
Résumé activité
===============
 On crée un tableau Finess x Jour de l'année permettant de voir rapidement où sont les "trous". A partir du tableau __t__ on crée un dataframe __a__ compotant deux colonnes: la date du jour et le nombre de RPU correspondants pour l'ensemble des SU d'Alsace. Ce dataframe peut être utilisé pour __Dygraph__.

On peut aussi l'utiliser pour tracer le graphe correspondant.

```{r activite}
t <- table(as.Date(dx$ENTREE), dx$FINESS)
s <- rowSums(t)
b <- rownames(t)
a <- as.data.frame(cbind(b,s))
colnames(a) <- c("Date","RPU")
a$Date <- as.Date(a$Date)
a$RPU <- as.numeric(as.character(a$RPU))

plot(a$Date, a$RPU, type="l", ylab="nombre de RPU", xlab="Année 2014", main="Activité des SU d'Alsace en nombre de RPU")

library("xts", lib.loc="/home/jcb/R/x86_64-pc-linux-gnu-library/3.1")

x <- as.xts(a$RPU, a$Date)

z <- as.zoo(x)
plot(z, col="blue")
lines(rollmean(z, 7), col="red")

plot.xts(x, ylab="nombre de RPU", xlab="Année 2014", main="Activité des SU d'Alsace en nombre de RPU", col="blue")
lines(rollmean(z, 7), col="red")
```
Activité 2013-2014
==================

Voir __Activités_2013-2014.Rmd__


C3F - Mai 2014
==============

A partir du 16 mai 2014 la clinique des 3 frontières passe au n°Finess __680020096__. Ce changement provoque une erreur dans le fichier transmis par Mr Nold car les données de la clinique apparaissent deux fois: une fois sous "3Fr" et une fois sous "680020096". Les données sont corrigées jusqu'au 19/05 inclus. Anomalie signalée le 31/05/2014 , en attente.

Erreur corrigée à partir du 22/05/2014 mais 6 jours sont doublonnés, du 16/5 au 23/5/2014 inclu.

Algorithme de correction(12/06/2014):
- on isole les 6 jours concernés dans le datafame __c3f__
- on trie les lignes par ordre de date/heure d'entrée de sorte que tous les doublons se trouvent sur deux lignes consécutives
- on crée le dataframe __c3__ en ne retenant que les lignes impaires de c3f. En pratique on ne garde qu'une ligne sur 2 ce qui permet d'éliminer les doublons
- on forme un dataframe avec tous les enregistrements du mois de mai, sauf ceux correspondants à la C3F: __d05_saufc3f__
- de la même façon on forme le dataframe complémentaire qui ne contient que les enregistrement de la C3F: __d05_3fr__
- de d05_3fr on retire tous les enregistrements correspondants aux jours litigieux, ce qui donne __d05_3fr_sauf_doublons__
- on reforme un dataframe __d05_corrige__ qui est la concaténation des lignes correspondant à la C3F moins les doublons
- on vérifie que tout est bon en faisant un table()
- on rebaptise le dataframe corrigé en __d05__ et on le sauvegarde
- on recrée le dataframe __dx__ concaténation du mois de mai avec les autres mois de l'année et on sauvegarde le tout dans __rpu2014d0105.Rda__.

```{}
c3f <- d05[as.Date(d05$ENTREE) >= "2014-05-16" & as.Date(d05$ENTREE) <= "2014-05-23" & d05$FINESS == "3Fr",]
c3fo <- c3f[order(c3f$ENTREE),]
c3 <- c3fo[1,]
seq <- seq(3, nrow(c3fo), by=2)
for(i in seq){c3 <- rbind(c3, c3fo[i,])}
d05_saufc3f <- d05[d05$FINESS != "3Fr",]
d05_3fr <- d05[d05$FINESS == "3Fr",]
d05_3fr_sauf_doublons <- d05_3fr[as.Date(d05_3fr$ENTREE) < "2014-05-16" | as.Date(d05_3fr$ENTREE) > "2014-05-23",]
d05_corrige <- rbind(d05_saufc3f, d05_3fr_corrige)
table(as.Date(d05_corrige$ENTREE), d05_corrige$FINESS)
d05 <- d05_corrige
save(d05, file="rpu2014d05.Rda")
load("rpu2014d0104.Rda")
dx <- rbind(a, d05)
save(dx, file="rpu2014d0105.Rda")

```
CCL: les données du mpois de Mai 2014 sont 'propres' à la date du 12 juin 2014.

Anomalies du mois de mai:

- Ste Anne a fait unessai du 12 au 16 mai, et semle être passé en production depuisle 28 mai 2014. A vérifier en juin.
- CH Alkirch: toujours des ratées dans la transmission: 1, 4, 11, 27, 29 mai
- CHM: 9, 10, 22 nb anormalement bas de assages
- Roosvelt: 13 mai nnb de RPU < 10
- CH Selestat: 13, 15, 16,17 moins de 5 RPU

- 158 346 RPU au 31 mai 2014. Comparaison avec 2013:
```{load("../RPU_2013/rpu2013d0112.Rda")
d_2013_au31mai <- d1[as.Date(d1$ENTREE) < "2013-06-01",]
nrow(d_2013au31mai)
}
# 137 612
```
soit __20734__ RPU de plus soit environ 400.000 RPU en 2014.

Rajouter:
```{}
Résumé d'activité
Radar
```

Juin 2014
=========

Au 6/6 Ste Anne n'émet rien => vérifier

Essai d'utilisation de Xts
--------------------------
 On forme une table de contingence en croisant la date d'entrée et le Finess. Le croisement donne le total des RPU par jour pour un SU. Le tableau est transformé en dataframe par __as.data.frame.matrix__. La transformation en dataframe permet de préserver la nature des colonnes. On crée une colonne __date__ correspondant à chaque jour du mois que l'on ajoute au dataframe et cette nouvelle colonne est mise au format 'Date'. C'est elle qui servira d'index à l'objet xts. On crée également une colonne total qui est ajoutée au dataframe.
 
 Le rataframe est transformé en objet __xts__ qui peut être plotté. On ajoute la moyenne mobile avec __rollappy__ (j'ai essayé avec rollmean mais j'ai une erreur ?)
 
```{r xts_test}
library(xts)
t <- table(as.Date(d05$ENTREE), d05$FINESS) 
date <- rownames(t)
a <- as.data.frame.matrix(t)
a <- cbind(a, date)
a$date <- as.Date(a$date)
a$total <- rowSums(a[,1:14])
ts <- xts(a, order.by = a$date)
plot(ts$total, main="Activité du mois de Mai", ylab="nombre de RPU")
lines(rollapply(ts$total, 7, mean), col="red")
legend("topleft", legend="Moyenne mobile", col="red", lty=1)

plot(ts$total,minor.ticks=FALSE, col = "gray")
lines(rollapply(ts$total, 7, mean), col="red")

plot(ts$total["2014-02/2014-03"],minor.ticks=FALSE, col = "gray")
lines(rollapply(ts$total["2014-01-25/2014-03"], 7, mean), col="red")

```
fonction dérivée

A partir du fichier habituel des RPU retourne un objet xts ayant autant de 
colonnes qu'il y a de SU dans d plus 2 colonnes supplémentaires:
- date de type 'Date' qui sert d'index à xts
- total nombre total de RPU par jour

d données RPU

rpu2xts <- function(d){
  library(xts)
  t <- table(as.Date(d$ENTREE), d$FINESS)
  date <- rownames(t)
  a <- as.data.frame.matrix(t)
  a <- cbind(a, date)
  a$date <- as.Date(a$date)
  a$total <- rowSums(a[,1:14])
  ts <- xts(a, order.by = a$date)
  ts
}



